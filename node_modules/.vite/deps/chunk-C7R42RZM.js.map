{
  "version": 3,
  "sources": ["../../src/.internal/core/util/Math.ts"],
  "sourcesContent": ["import type { IPoint } from \"./IPoint\";\nimport { isNumber } from \"./Type\";\nimport type { IBounds } from \"./IBounds\";\n\n/**\n * ============================================================================\n * CONSTANTS\n * ============================================================================\n * @hidden\n */\nexport const PI = Math.PI;\nexport const HALFPI = PI / 2;\nexport const RADIANS = PI / 180;\nexport const DEGREES = 180 / PI;\n\n/**\n * Rounds the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\n * @return Rounded value\n */\nexport function round(value: number, precision?: number, floor?: boolean): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\n\t\tlet rounded = Math.round(value);\n\t\tif (floor) {\n\t\t\tif (rounded - value == 0.5) {\n\t\t\t\trounded--;\n\t\t\t}\n\t\t}\n\t\treturn rounded;\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.round(value * d) / d;\n\t}\n}\n\n\n/**\n * Ceils the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @return Rounded value\n */\nexport function ceil(value: number, precision: number): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\t\treturn Math.ceil(value);\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.ceil(value * d) / d;\n\t}\n}\n\n\n/**\n * [getCubicControlPointA description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\n}\n\n/**\n * [getCubicControlPointB description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointB(p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\n}\n\n\nexport function fitToRange(value: number, min: number, max: number): number {\n\treturn Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns sine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function sin(angle: number): number {\n\treturn Math.sin(RADIANS * angle);\n}\n\n/**\n * Returns tan of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function tan(angle: number): number {\n\treturn Math.tan(RADIANS * angle);\n}\n\n/**\n * Returns cosine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Cosine\n */\nexport function cos(angle: number): number {\n\treturn Math.cos(RADIANS * angle);\n}\n\n// 0 to 360\nexport function normalizeAngle(value: number): number {\n\tvalue = value % 360;\n\tif (value < 0) {\n\t\tvalue += 360;\n\t}\n\treturn value;\n}\n\n// TODO this doesn't work properly for skewing, and it's probably broken for rotation too\nexport function getArcBounds(cx: number, cy: number, startAngle: number, endAngle: number, radius: number): IBounds {\n\n\tlet minX = Number.MAX_VALUE;\n\tlet minY = Number.MAX_VALUE;\n\tlet maxX = -Number.MAX_VALUE;\n\tlet maxY = -Number.MAX_VALUE;\n\n\tlet bpoints = [];\n\n\tbpoints.push(getArcPoint(radius, startAngle));\n\tbpoints.push(getArcPoint(radius, endAngle));\n\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\n\t\tif (angle >= startAngle && angle <= endAngle) {\n\t\t\tbpoints.push(getArcPoint(radius, angle));\n\t\t}\n\t}\n\n\tfor (let i = 0; i < bpoints.length; i++) {\n\t\tlet pt = bpoints[i];\n\t\tif (pt.x < minX) { minX = pt.x; }\n\t\tif (pt.y < minY) { minY = pt.y; }\n\t\tif (pt.x > maxX) { maxX = pt.x; }\n\t\tif (pt.y > maxY) { maxY = pt.y; }\n\t}\n\n\treturn ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });\n}\n\n/**\n * Returns point on arc\n *\n * @param center point\n * @param radius\n * @param arc\n * @return {boolean}\n */\nexport function getArcPoint(radius: number, arc: number) {\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\n}\n\n\nexport function mergeBounds(bounds: IBounds[]): IBounds {\n\tconst len = bounds.length;\n\n\tif (len > 0) {\n\t\tlet bound = bounds[0];\n\t\tlet left = bound.left;\n\t\tlet top = bound.top;\n\t\tlet right = bound.right;\n\t\tlet bottom = bound.bottom;\n\n\t\tif (len > 1) {\n\t\t\tfor (let i = 1; i < len; i++) {\n\t\t\t\tbound = bounds[i];\n\t\t\t\tleft = Math.min(bound.left, left);\n\t\t\t\tright = Math.max(bound.right, right);\n\t\t\t\ttop = Math.min(bound.top, top);\n\t\t\t\tbottom = Math.max(bound.bottom, bottom);\n\t\t\t}\n\t\t}\n\n\t\treturn { left, right, top, bottom };\n\t}\n\treturn { left: 0, right: 0, top: 0, bottom: 0 };\n}\n\n\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\n\n\tif (startAngle > endAngle) {\n\t\tlet temp: number = startAngle;\n\t\tstartAngle = endAngle;\n\t\tendAngle = temp;\n\t}\n\n\tvalue = normalizeAngle(value);\n\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n\tif (value < startAngle) {\n\t\tvalue += 360 * (count + 1);\n\t}\n\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\n\n\tif (value > endAngle) {\n\n\t\tif (value - 360 > startAngle) {\n\t\t\tvalue -= 360;\n\t\t}\n\t\telse {\n\t\t\tif (value < maxEnd) {\n\t\t\t\tvalue = endAngle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = startAngle;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (value < startAngle) {\n\t\tif (value > maxStart) {\n\t\t\tvalue = startAngle;\n\t\t}\n\t\telse {\n\t\t\tvalue = endAngle;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nexport function inBounds(point: IPoint, bounds: IBounds) {\n\tif (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\n\tif (!point2) {\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\n\t}\n\tlet diffX: number = point2.x - point1.x;\n\tlet diffY: number = point2.y - point1.y;\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\n\tif (angle < 0) {\n\t\tangle += 360;\n\t}\n\treturn normalizeAngle(angle);\n}\n\n/**\n * [getPointOnQuadraticCurve description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param pointA        [description]\n * @param pointB        [description]\n * @param controlPoint  [description]\n * @param position      [description]\n * @return [description]\n */\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n\treturn { x: x, y: y };\n}\n\nexport function getPointOnLine(pointA: IPoint, pointB: IPoint, position: number): IPoint {\n\treturn { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };\n}\n\n\n/**\n * Returns the closest value from the array of values to the reference value.\n *\n * @param values  Array of values\n * @param value   Reference value\n * @return Closes value from the array\n */\nexport function closest(values: number[], referenceValue: number): number {\n\treturn values.reduce(function(prev, curr) {\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\n\t});\n}\n\nexport function boundsOverlap (bounds1:IBounds, bounds2:IBounds) {  \n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}"],
  "mappings": "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",
  "names": []
}
